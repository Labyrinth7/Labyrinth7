namespace LabyrinthGameEngine
{
    using System;
    using System.Linq;

    public class LabyrinthFactory
    {
        public Labyrinth CreateLabyrinth(int labyrinthRows, int labyrinthCols)
        {
            Labyrinth currentLabyrinth = new Labyrinth(labyrinthRows, labyrinthCols);

            int initialPlayerPositionX = currentLabyrinth.CenterOfCols;
            int initialPlayerPositionY = currentLabyrinth.CenterOfRows;

            while (!CheckIfAnyExit(currentLabyrinth.Clone<Labyrinth>(), initialPlayerPositionX, initialPlayerPositionY))
            {
                //currentLabyrinth.Display(new int[] {3, 3});
                //Console.ReadLine();
                currentLabyrinth.FillMatrix();
            }

            return currentLabyrinth;
        }

        private bool CheckIfAnyExit(Labyrinth labyrinth, int positionX, int positionY)
        {

            labyrinth.Display(new int[] { 3, 3 });
            Console.ReadLine();

            char wallSymbol = labyrinth.WallSymbol;
            char blankSymbol = labyrinth.BlankSymbol;
            char visitedSymbol = '0';

            int playerStartPositionX = positionX;
            int playerStartPositionY = positionY;

            labyrinth[playerStartPositionY, playerStartPositionX] = visitedSymbol;

            bool isTrue = false;

            // Border cases STARTS
            if (playerStartPositionX == 0 ||
                playerStartPositionX == labyrinth.Rows - 1 ||
                playerStartPositionY == 0 ||
                playerStartPositionY == labyrinth.Cols - 1)
            {
                return true;
            }

            if (labyrinth[playerStartPositionY + 1, playerStartPositionX] == wallSymbol &&
                labyrinth[playerStartPositionY, playerStartPositionX + 1] == wallSymbol &&
                labyrinth[playerStartPositionY - 1, playerStartPositionX] == wallSymbol &&
                labyrinth[playerStartPositionY, playerStartPositionX - 1] == wallSymbol)
            {
                return false;
            }
            // Border cases STOPS

            int nextPositionY;
            int nextPositionX;

            // up
            nextPositionY = playerStartPositionY - 1;
            nextPositionX = playerStartPositionX;

            if (isTrue == false &&
                labyrinth[nextPositionY, nextPositionX] != visitedSymbol &&
                labyrinth[nextPositionY, nextPositionX] == blankSymbol)
            {
                labyrinth[nextPositionY, nextPositionX] = visitedSymbol;
                isTrue = CheckIfAnyExit(labyrinth, playerStartPositionX, playerStartPositionY);

                if (isTrue)
                {
                    return true;
                }
            }

            // right
            nextPositionY = playerStartPositionY;
            nextPositionX = playerStartPositionX + 1;

            if (isTrue == false &&
                labyrinth[playerStartPositionY, nextPositionX] != visitedSymbol &&
                labyrinth[playerStartPositionY, nextPositionX] == blankSymbol)
            {
                labyrinth[playerStartPositionY, nextPositionX] = visitedSymbol;
                isTrue = CheckIfAnyExit(labyrinth, playerStartPositionX, playerStartPositionY);

                if (isTrue)
                {
                    return true;
                }
            }

            // down
            nextPositionY = playerStartPositionY + 1;
            nextPositionX = playerStartPositionX;

            if (isTrue == false &&
                labyrinth[nextPositionY, nextPositionX] != visitedSymbol &&
                labyrinth[nextPositionY, nextPositionX] == blankSymbol)
            {
                labyrinth[nextPositionY, nextPositionX] = visitedSymbol;
                isTrue = CheckIfAnyExit(labyrinth, playerStartPositionX, playerStartPositionY);

                if (isTrue)
                {
                    return true;
                }
            }

            // left
            nextPositionY = playerStartPositionY;
            nextPositionX = playerStartPositionX - 1;

            if (isTrue == false &&
                labyrinth[nextPositionY, nextPositionX] != visitedSymbol &&
                labyrinth[nextPositionY, nextPositionX] == blankSymbol)
            {
                labyrinth[nextPositionY, nextPositionX] = visitedSymbol;
                isTrue = CheckIfAnyExit(labyrinth, playerStartPositionX, playerStartPositionY);

                if (isTrue)
                {
                    return true;
                }
            }

            return false;
        }
    }
}
