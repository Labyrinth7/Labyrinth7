namespace LabyrinthGameEngine
{
    using System;

    public class LabyrinthFactory
    {
        public Labyrinth CreateLabyrinth(int labyrinthRows, int labyrinthCols)
        {
            Labyrinth currentLabyrinth = new Labyrinth(labyrinthRows, labyrinthCols);

            int initialPlayerPositionX = currentLabyrinth.CenterOfCols;
            int initialPlayerPositionY = currentLabyrinth.CenterOfRows;

            while (!CheckIfAnyExit(currentLabyrinth.Clone<Labyrinth>(), initialPlayerPositionX, initialPlayerPositionY))
            {
                currentLabyrinth.FillMatrix();
            }

            return currentLabyrinth;
        }

        private bool CheckIfAnyExit(Labyrinth labyrinth, int positionX, int positionY)
        {
            //Console.ReadLine();
            //labyrinth.Display(new int[] { positionX, positionY });
            //Console.WriteLine(positionX);
            //Console.WriteLine(positionY);

            char wallSymbol = labyrinth.WallSymbol;
            char blankSymbol = labyrinth.BlankSymbol;
            char visitedSymbol = '0';

            int botStartPositionX = positionX;
            int botStartPositionY = positionY;

            labyrinth[botStartPositionY, botStartPositionX] = visitedSymbol;

            bool isAnyExit = false;

            // Border cases STARTS
            if (botStartPositionX == 0 ||
                botStartPositionX == labyrinth.Rows - 1 ||
                botStartPositionY == 0 ||
                botStartPositionY == labyrinth.Cols - 1)
            {
                return true;
            }

            if (labyrinth[botStartPositionY + 1, botStartPositionX] == wallSymbol &&
                labyrinth[botStartPositionY, botStartPositionX + 1] == wallSymbol &&
                labyrinth[botStartPositionY - 1, botStartPositionX] == wallSymbol &&
                labyrinth[botStartPositionY, botStartPositionX - 1] == wallSymbol)
            {
                return false;
            }
            // Border cases STOPS

            int nextPositionY;
            int nextPositionX;


            if (Check(labyrinth, botStartPositionX, botStartPositionY, Direction.Up, visitedSymbol, ref isAnyExit))
            {
                return true;
            }


            if (Check(labyrinth, nextPositionX, nextPositionY, Direction.Right, visitedSymbol, ref isAnyExit))
            {
                return true;
            }

            if (Check(labyrinth, nextPositionX, nextPositionY, Direction.Down, visitedSymbol, ref isAnyExit))
            {
                return true;
            }

            if (Check(labyrinth, nextPositionX, nextPositionY, Direction.Left, visitedSymbol, ref isAnyExit))
            {
                return true;
            }

            return false;
        }

        private bool Check(Labyrinth labyrinth, int botStartPositionX, int botStartPositionY, Direction direction, char visitedSymbol, ref bool isAnyExit)
        {
            int nextPositionY = int.MinValue;
            int nextPositionX = int.MinValue;

            switch(direction)
            {
                case Direction.Up:
                    nextPositionY = botStartPositionY - 1;
                    nextPositionX = botStartPositionX;
                    break;
                case Direction.Right:
                    nextPositionY = botStartPositionY;
                    nextPositionX = botStartPositionX + 1;
                    break;
                case Direction.Down:
                    nextPositionY = botStartPositionY + 1;
                    nextPositionX = botStartPositionX;
                    break;
                case Direction.Left:
                    nextPositionY = botStartPositionY;
                    nextPositionX = botStartPositionX - 1;
                    break;
            }

            if (isAnyExit == false && labyrinth[nextPositionY, nextPositionX] == labyrinth.BlankSymbol)
            {
                labyrinth[nextPositionY, nextPositionX] = visitedSymbol;
                isAnyExit = CheckIfAnyExit(labyrinth, nextPositionY, nextPositionX);

                if (isAnyExit)
                {
                    return true;
                }
            }
            return false;
        }
    }
}
